# Drone Game Envionment Simulation Project: Instructions for Simulation

A dynamic drone navigation game where the objective is to control a drone to collect as many targets as possible, while also avoiding collisions with obstacles.

## 1- Installation and Running

- Prerequisites
    - GCC compiler (can be installed via `sudo apt-get install build-essential`)
    - `ncurses` library (can be installed via `sudo apt-get install libncurses5-dev`)
    - `make` (can be installed via `sudo apt-get install make`)

- Building and Running the Simulation
    1.  Navigate to the project directory: 
        ```bash
        cd proj_DroneGame/
        ```
    2.  Run the following command to build the project:
        ```bash
        make clean && make
        ```
        This will generate an executable named `arp1`.
    3. Run the executable:
        ```bash
        ./arp1
        ```
    4. Clean: To remove all compiled files and start fresh
        ```bash
        make clean
        ```

## 2- Operational Instructions

- A full-screen **ncurses** interface appears.
- The screen is divided into:
  - **Left world panel** (drone, obstacles, targets)
  - **Right inspection panel** (state, forces, score, logs)

During execution:

- The **Keyboard process (I)** captures your keypresses.
- The **Blackboard Server (B)** updates forces, world state, UI, scoring.
- The **Dynamics process (D)** simulates the drone motion.
- The **Obstacle generator (O)** and **Target generator (T)** periodically spawn entities.
- The **Watchdog process (W)** monitors system health via heartbeats. It detects freezes and terminates the system on failure.

To exit cleanly, press `q` or `Q` at any moment.

## 3- Game Rules
-   **Objective**: Fly the drone to collect as many **Targets** (Green `+`) as possible.
-   **Avoid**: **Obstacles** (Orange `O`).
-   **Physics**: The drone has physical properties (mass, viscosity) and inertia. A continuous *force* applied to it is controlled by the keyboard in a corresponding direction.
-   **Inspection**: The right panel shows the current state (Position, Velocity) and Score, and the time elapsed since a prior target has been collected.
-   **Run-time configuration**: Simulation parameters like Mass (`M`), Viscosity (`K`), and Time step (`dt`) can be modified in `params.txt` file.

## 4- Controls

### Directional Force Controls

```text
    w   e   r
    s   d   f
    x   c   v
```
Each press adds force in that direction:
- `w` → up-left  
- `e` → up  
- `r` → up-right  
- `s` → left  
- `d` → brake (zero force)  
- `f` → right  
- `x` → down-left  
- `c` → down  
- `v` → down-right  

### Special Commands
| Key | Function                          |
|-----|-----------------------------------|
| `d` | Brake (zero user-applied force)   |
| `p` | Pause / resume the simulation     |
| `O` | Reset drone position & velocity   |
| `q` | Quit the entire system            |

## 5- Behavior

The following describes how the drone world responds to user actions and how the different components interact.

### Drone Dynamics
- Simulated dynamic model.
- Numerical integration using timestep `dt` from `params.txt`.
- Smooth, continuous acceleration from user forces.

### Wall Repulsion
- Implemented in the **Dynamics process (D)**.
- When the drone approaches ±`world_half`, a **Khatib repulsive** force pushes it inward.
- Prevents the drone from crossing the world boundaries.

### Obstacle Behavior

- Obstacles are periodically generated by process **O**:
  - Sampled inside an inner **safe region**.
  - Respect minimum spacing between obstacles.
- The Server (B) adds **virtual-key repulsion**:
  - Computes a continuous **Khatib repulsive** vector.
  - Projects that vector onto the 8 control directions.
  - Applies the strongest direction as a “virtual key press”.

### Target Behavior
- Targets are generated by **T**:
  - In a central disk region.
  - Fairly away from walls and obstacles.
- When the drone’s distance to a target < `R_hit`:
  - The target is **collected**.
  - Score increments.
  - Time of last hit is recorded.

### Spawning behavior
- Each obstacle/target has a finite lifetime measured in simulation steps.
- Expired entities disappear automatically.
- B only accepts a new obstacle batch if no active obstacles remain.
- Targets may spawn even if obstacles exist, but unsafe targets are filtered.

### Pause Behavior
- Drone motion, world state and entity lifetimes freeze. 
- UI still updates to show paused status.
- Forces are zeroed. 
- Lifetimes for obstacles and targets do not decrement.  
- No new obstacle and target spawn batches are accepted.  

### Watchdog Behavior
- **Role**: Ensures the system is responsive.
- **Chain of Trust**: The Server only sends a heartbeat when it receives a physics update. Thus, the Watchdog effectively monitors the entire simulation loop (Dynamics + Server), not just the Server process.
- **Mechanism**:
  - The **Server (B)** sends a `SIGUSR1` "heartbeat" signal to the **Watchdog (W)** every time it receives a state update from Dynamics (every `dt`).
- **Failure Modes**:
  1.  **Warning**: If no heartbeat is received for **2 seconds** (configured via `wd_warn_sec`), W sends `SIGUSR2` to B, triggering a **blinking "WATCHDOG WARNING" banner** on the UI. The UI also displays a **countdown timer** showing the time remaining until system termination. If the system resumes (Server receives valid input), the warning automatically vanishes.
  2.  **Termination**: If no heartbeat is received for **10 seconds** (configured via `wd_kill_sec`), W sends `SIGTERM` to all processes, safely shutting down the simulation.

## 10. Logging
The system implements a per-process logging strategy. Upon startup, the `logs/` directory is automatically created if it does not exist.
Each active process writes to its own dedicated log file:

| Process | Log File | Description |
| :--- | :--- | :--- |
| **Server** | `logs/server.log` | Records critical events, IPC errors, and final score. |
| **Dynamics** | `logs/dynamics.log` | Logs physics engine status and force application events. |
| **Obstacles** | `logs/obstacles.log` | Logs batch generation events and spawn counts. |
| **Targets** | `logs/targets.log` | Logs target generation batches. |
| **Watchdog** | `logs/watchdog.log` | Logs heartbeats, warnings, and shutdown triggers. |

**Log Format**:
`[TAG] MESSAGE pid=12345 time=YYYY-MM-DD HH:MM:SS`


# On Assignment-1 comments recieved in the evaluation
## 1- Solution Correctness
### 1.1- Repulsive Force
### 1.2- Sequentially spawned targets
### 1.3 - improvement on flickering window
### 1.3- Reasonable speed Force limit on Input Force
### 1.4- target attration
### 1.5- Online parameter manipulation
## 2- 
## 3- Functionality
### repulsion force implementation

## 4- Error Handling
## 5- Code Quality
### 5.1 Project structure 
The project now has been corrected to adhere to a standard directory structure. Source files are strictly organized in `src/`, while all compilation artifacts are generated in `build/` to keep the root directory clean.

```text
proj_DroneGame/
│
├── src/          <-- Source files (.c)
│   ├── main.c           # Entry point (process management)
│   ├── server.c         # Blackboard server logic
│   ├── dynamics.c       # Drone physics simulation
│   ├── keyboard.c       # User input handling
│   ├── obstacles.c      # Obstacle generation
│   ├── targets.c        # Target generation
│   ├── watchdog.c       # System monitoring
│   └── util.c           # Utility functions
│
│
├── headers/      <-- Header files (.h)
│   ├── messages.h       # IPC message definitions
│   ├── params.h         # Simulation parameters struct
│   ├── dynamics.h       # Drone physics simulation
│   ├── keyboard.h       # User input handling
│   ├── obstacles.h      # Obstacle generation
│   ├── targets.h        # Target generation
│   ├── watchdog.h       # System monitoring
│   └── util.h           # Utility functions
│
├── build/        <-- Compiled object files (.o) and intermediate build artifacts
│
├── logs/         <-- Runtime logs generated by each process
│
├── install/      <-- Installation scripts and compiled binaries 
│
├── Makefile      <-- Build configuration
├── README.md     <-- Project documentation
├── Architecture.md   <-- Project architecture description
├── params.txt    <-- Simulation parameters
```

**Key Directories:**
- **`src/`**: Contains all the implementation code.
- **`headers/`**: Contains function prototypes and common data structures.
- **`build/`**: Keeps the project root clean by storing all compiled object files here.
- **`logs/`**: Stores execution logs for debugging each process. 

### 5.2 Improved Commenting and Documentation

Comprehensive inline documentation has been retrofitted across all source files to also improve readability.

**Key improvements include:**
- **Function Header Blocks**: Critical functions now include detailed descriptions of their purpose, input parameters, return values, and side effects.
- **IPC Logic Annotation**: Complex inter-process communication flows (via pipes) are explicitly mapped out in comments to clarify data ownership and synchronization points.
- **Algorithmic Context**: Physics calculations (e.g., Khatib repulsion, dynamic integration) are accompanied by references to the underlying mathematical models.
- **Standardization**: formatting consistency has been applied to ensure headers and inline notes follow a unified style guide.